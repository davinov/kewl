
<h1>Kewl brunch skeleton walkthrough</h1>
<div class="introduction">
  Angular apps are client-side apps, often single-page.
  They land their code on the client, then load on demand data from the server using AJAX.
  Unlike regular web pages (without AJAX) where all the content is generated by the server, when the content changes,
  useful indicators provided by the browser are not triggered (loading bar, error messages,...).
  Moreover, nothing indicates to the user something is happening, preventing him to diagnose an eventual error.
  Angular provides all the tools we need to address this lacks.
  Let's walk though this boilerplate code to start an Angular app capable of communicating elegantly with APIs.
  
</div>
<ol>
  <li id="step-01" class="step">
    <h2>Starting a new brunch project<small> The beginning of all good story</small></h2><p>To start a client-only app easily, I suggest using tools like <a href="http://brunch.io">Brunch</a>,
<a href="http://yeoman.io/">Yeoman</a> or <a href="http://lauterry.github.io/ngTailor/">ngTailor</a>.</p>
<p>Let&#39;s use Brunch and generate a project based on the <a href="http://vbrajon.fr">@vbrajon</a>&#39;s
<a href="https://github.com/vbrajon/brunch-skeleton">brunch skeleton</a>:</p>
<pre><code>brunch new gh:vbrajon/brunch-skeleton kewl-app
cd kewl-app
brunch watch --server
</code></pre><p>And watch your app live on <a href="http://localhost:3333">http://localhost:3333</a> !</p>

    <div class="tip"><p>You can publish you client-side app really easily on Github pages by inititing a repo in your <code>public</code> folder,
switching to gh-pages branch, commiting all files there and pushing to your repo on Github.
See the README file for more info.</p>

    </div>
  </li>
  <li id="step-02" class="step">
    <h2>Creating our backend with Express<small> Love at the first sight</small></h2><p>Let&#39;s create some backend for our brand new Angular app.
Having a REST API as a backend is a great choice, as it&#39;s allow other developers to create easily new fontends to
use the data it exposes (native mobile apps, desktop apps,...) and interacts with others services.
The easy syntax of <a href="http://expressjs.com/">Express.js</a> will help us creating one easily.</p>
<h3 id="serving-our-front-end-with-express">Serving our front-end with Express</h3>
<p>As Brunch&#39;s basic server do, we need to send the user our static files (the Angular frontend).
After Express&#39;s install with <code>npm install express --save</code>, we create a new <code>server/api.coffee</code> file containing :</p>

    <hljs language="coffeescript" include="&quot;code/server/api-1.coffee.pre&quot;"></hljs><p>We can than start our server with <code>./node_modules/.bin/coffee server/api.coffee</code>.</p>

    <div class="tip"><p>By installing globally CoffeeScript (<code>npm install -g coffeescript</code>), you can use only <code>coffee server/api.coffee</code>.</p>

    </div><h4 id="integrating-express-with-brunch">Integrating Express with Brunch</h4>
<p>As Brunch provide us an easy development server, we might want to continue using our <code>brunch watch --server</code> to
be the only requirement to start the app.
In Brunch config file <code>config.coffee</code>:</p>

    <hljs language="coffeescript" include="&quot;code/config-1.coffee.pre&quot;"></hljs><p>And in <code>server/server.coffee</code> :</p>

    <hljs language="coffeescript" include="&quot;code/server/server-1.coffee.pre&quot;"></hljs><p>Now, <code>brunch watch --server</code> starts our Express serving our frontend, so the line <code>api.start()</code> is no longer
desired in <code>server/api.coffee</code>.</p>
<h3 id="some-basic-routes">Some basic routes</h3>
<p>In this example, we&#39;ll create the most basic REST API of the world: one that handles a list of To Dos.</p>

    <div class="note"><p>In a nutshell REST services are built around fours verbs:</p>
<ul>
<li><code>GET</code> to aquire data</li>
<li><code>POST</code> to add data</li>
<li><code>PUT</code> to update data</li>
<li><code>DELETE</code> to remove data</li>
</ul>
<p>E.g., to acquire this webpage&#39;s content, your browser is doing a <code>GET</code> request to the server that respond
with the code of the webpage. Same for the pictures, the fonts...
When you&#39;re submitting a form, it&#39;s generally a <code>POST</code> request.</p>
<p>Request are addressed to an URL and can contain some extra data:</p>
<pre><code>POST http://my-awesome-website.com/newsletter/subscription
{
  email: &#39;give-me-spam@me.com&#39;
}
</code></pre>
    </div><p>Let&#39;s implement a very easy example: a ToDo list.
Consider an array of ToDos like this:</p>

    <hljs language="coffeescript" include="&quot;code/to-do-model.coffee.pre&quot;"></hljs><p>We need the following routes:</p>
<ul>
<li><code>GET /todo</code> will send the list</li>
<li><code>POST /todo</code> will add an item</li>
<li><code>DELETE /todo/:id</code> will mark an id as done</li>
</ul>
<p>Express makes easy to create this routes easily:</p>

    <hljs language="coffeescript" include="&quot;code/server/api-2.coffee.pre&quot;"></hljs>
    <div class="tip"><p>API are testable without any frontend with tools like <a href="http://getpostman.com">POSTMAN</a>.</p>

    </div><h3 id="angular-way-of-interacting-with-the-api">Angular way of interacting with the API</h3>
<p>As interaction between a REST API is a common pattern in Angular apps, a module called
<a href="http://docs.angularjs.org/api/ngResource">ngResource</a> provides us a useful <code>$resource</code> service to map objects
described in the API.</p>
<p>To install ngResource module:</p>

    <hljs language="bash" include="&quot;code/install-ng-resource.sh&quot;"></hljs>
    <div class="note"><p>Brunch normally uses the <code>main</code> attribute from <code>.bower.json</code> to detect the file he needs to include in vendors
(it&#39;s the strategy used by the <a href="https://github.com/scotch/angular-brunch-seed">angular-brunch-seed</a>.
Symlinking the files we want to include seems better to me though as we can inlude other files, control their
order (also possible with <code>before</code> and <code>after</code> attributes in brunch&#39;s <code>config.coffee</code>) and avoid Brunch&#39;s warning when
a <code>.bower.json</code> is missing (which is often the case).</p>

    </div><p>Let&#39;s create a new module <code>kewl.todo</code> in our app in a <code>toDo</code> folder (<a href="http://www.johnpapa.net/angular-growth-structure/">modularized folder
structure</a>):</p>

    <tabset>
      <tab heading="todo/todo.coffee">
        <hljs language="coffeescript" include="&quot;code/app/todo/todo-1.coffee.pre&quot;"></hljs>
      </tab>
      <tab heading="todo/todo.jade">
        <pre>h1 To do list

accordion
accordion-group.to-do(ng-repeat='toDo in toDoList', ng-class='{done: toDo.done}')
  accordion-heading {{toDo.title}}
  {{toDo.details}}</pre>
      </tab>
      <tab heading="todo/todo.less">
        <pre>.to-do {
  &.done {
    .text-muted;
    .panel-heading {
      .text-muted;
      text-decoration: line-through;
    }
  }
}
</pre>
      </tab>
    </tabset><p>That handles display of tasks. We still need to create the front-end for POST/DELETE requests:</p>

    <tabset>
      <tab heading="todo/todo.coffee">
        <hljs language="coffeescript" include="&quot;code/app/todo/todo-2.coffee.pre&quot;"></hljs>
      </tab>
      <tab heading="todo/todo.jade">
        <pre>h1 To do list

accordion
  accordion-group.to-do(ng-repeat='toDo in toDoList', ng-class='{done: toDo.done}')
    accordion-heading {{toDo.title}}
      button.mark-as-done(ng-click='markAsDone(toDo)')
        i.icon.icon-check
    {{toDo.details}}
  accordion-group.to-do.new
    accordion-heading
      .row
        input.title(type='text', placeholder='Add a new task...', ng-model='newToDo.title')
        button.send(ng-click='addNewToDo()', ng-disabled='sendButtonDisabled')
          i.icon.icon-plus
          |  Send
    textarea(placeholder='More details?', ng-model='newToDo.details')
    </pre>
      </tab>
      <tab heading="todo/todo.less">
        <pre>.to-do {
  .mark-as-done {
    .btn;
    .btn-success;
    .pull-right;
    padding: @padding-xs-vertical/2 @padding-xs-horizontal;
  }
  
  &.done {
    .text-muted;
    .panel-heading {
      .text-muted;
      text-decoration: line-through;
    }
  }
  
  &.new {
    .title {
      .form-control;
      .make-xs-column(8);
      .make-sm-column(10);
    }
  .send {
      .btn;
      .btn-primary;
      .make-xs-column(4);
      .make-sm-column(1);
      .make-sm-column-offset(1);
  }
  textarea {
      .form-control;
  }
  }
}
</pre>
      </tab>
    </tabset><p>At this point, our to-do list is fully functionnal, except for a little flickering when the object <code>toDoList</code> is
queried. To avoid that effect, only affect <code>$scope.toDoList</code> when the server has answered:</p>
<pre><code>$scope.refreshToDoList = -&gt;
  ToDoList.query (response) -&gt; # function that will be called on success
    $scope.toDoList = response
</code></pre>
  </li>
  <li id="step-03" class="step">
    <h2>Interceptors saving the user from silence<small> Angular/API communication therapy</small></h2><p>As user, when interacting with the server or changing route, we&#39;ll like to be informed that something is happening
behind the scene. The usual UX pattern when requesting something through the web is to have a loading indicator,
from the browser: <img src="img/loading-indicator-chromium.png" alt="Loading indicator from Chromium"></p>
<p>When loading asynchronous data without refeshing the webpage (AJAX calls) like Angular does, these indicators are
not triggered.</p>
<p>Fortunatly, Angular provides <a href="http://docs.angularjs.org/api/ng/service/$http#interceptors">interceptors</a> to catch
requests before and after they&#39;re sent.</p>
<h4 id="implementing-a-loading-indicator">Implementing a loading indicator</h4>
<p>Interceptors are stored in the <code>$httpProvider.interceptor</code>. They are registered using <code>$httpProvider</code> like this:</p>

    <hljs language="coffeescript" include="&quot;code/app/app-1.coffee.pre&quot;"></hljs><p>To implement a loading indicator, we can add to our <code>app.coffee</code>:</p>

    <hljs language="coffeescript" include="&quot;code/app/app-2.coffee.pre&quot;"></hljs><p>The <code>$rootScope.loading</code> variable can now be used to display an indicator, like the corner indicator from
<a href="http://tympanus.net/Development/CreativeLoadingEffects/">creative loading effects</a>:</p>

    <tabset>
      <tab heading="index.jade">
        <pre>body
  [...]
  .loading-indicator(ng-show='$root.loading')
  [...]
  </pre>
      </tab>
      <tab heading="app.less">
        <pre>.loading-indicator {
  @loading-indicator-size: 300px;
  
  position: fixed;
  top: 0;
  right: 0;
  
  width: @loading-indicator-size;
  height: @loading-indicator-size;
  background: @navbar-default-bg;
  background: rgba(red(@navbar-default-bg), green(@navbar-default-bg), blue(@navbar-default-bg), 0.7);
  .transition(all 0.3s);
  -webkit-transform: translateX(50%) translateY(-50%) rotate(45deg);
  transform: translateX(50%) translateY(-50%) rotate(45deg);
  pointer-events: none;
  
  @circles-color-1: #fff;
  @circles-color-2: @brand-primary;
  &::before,
  &::after {
    position: absolute;
    bottom: @loading-indicator-size/10;
    left: @loading-indicator-size/2;
    display: block;
    border: 5px solid @circles-color-1;
    border-radius: 50%;
    content: '';
  }
  
  @big-circle-size: @loading-indicator-size*8/30;
  &::before {
    margin-left: -@big-circle-size/2;
    width: @big-circle-size;
    height: @big-circle-size;
    border-right-color: @circles-color-2;
    border-left-color: @circles-color-2;
    -webkit-animation: rotation 3s linear infinite;
    animation: rotation 3s linear infinite;
  }
  
  &::after {
    @small-circle-size: @big-circle-size/2;
    bottom: 50px;
    margin-left: -@small-circle-size/2;
    width: @small-circle-size;
    height: @small-circle-size;
    border-top-color: @circles-color-2;
    border-bottom-color: @circles-color-2;
    -webkit-animation: rotation 1s linear infinite;
    animation: rotation 1s linear infinite;
  }
  
  @-webkit-keyframes rotation {
    0% {
      -webkit-transform: rotate(0deg);
    }
    50% {
      -webkit-transform: rotate(180deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }
  
  @keyframes rotation {
    0% {
      transform: rotate(0deg);
    }
    50% {
      transform: rotate(180deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
}
</pre>
      </tab>
    </tabset><p>As our server is local, we may not have enought time to see the loader is actually working. We can add a delay
before our Express server to simulate some network latency:</p>

    <hljs language="coffeescript" include="&quot;code/server/api-3.coffee.pre&quot;"></hljs><p>You&#39;ll notice that if two request are sent, the first arrived disables the loading indicator. We can solve this
issue by counting the number of request waiting:</p>

    <hljs language="coffeescript" include="&quot;code/app/app-3.coffee.pre&quot;"></hljs>
    <div class="tip"><p>You can visualize variables in scopes by enabling the <a href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk">AngularJS
Batarang</a>
extension for Chrome.</p>

    </div><p>In case of error, the response interceptor function is never called, letting indefinitly the indicator on.
Let&#39;s handle this case to avoid bad behaviour when serving only the front-end (like on GitHub Pages).</p>

    <hljs language="coffeescript" include="&quot;code/app/app-4.coffee.pre&quot;"></hljs><h4 id="handling-errors">Handling errors</h4>
<p>As we&#39;re talking about errors, sometimes, the API is sending some errors that should be displayed to the user:
identification failures, inexistant object, wrong route...</p>
<p>E.g., we should return a &#39;bad request&#39; error when trying to mark as done a task that is already done:</p>

    <hljs language="coffeescript" include="&quot;code/server/api-4.coffee.pre&quot;"></hljs><p>And a 404 &#39;not found&#39; when the id doesn&#39;t match with any task:</p>

    <hljs language="coffeescript" include="&quot;code/server/api-5.coffee.pre&quot;"></hljs><p>Now, we just need an interceptor to pass the error to the scope and then display it:</p>

    <tabset>
      <tab heading="app.coffee">
        <hljs language="coffeescript" include="&quot;code/app/app-5.coffee.pre&quot;"></hljs>
      </tab>
      <tab heading="index.jade">
        <pre>body
  [...]
  .error(ng-repeat='error in $root.errors')
    strong {{ error.message }}
    small.pull-right Error {{ error.status }}
  [...]
  </pre>
      </tab>
      <tab heading="app.less">
        <pre>.error {
  .alert;
  .alert-danger;
  width: 100%;
  .make-sm-column(8);
  .make-sm-column-offset(2);
  .make-md-column(6);
  .make-md-column-offset(3);
  .make-lg-column(4);
  .make-lg-column-offset(4);
  z-index: 900;
  position: fixed;
  bottom: @padding-large-vertical;
  margin: auto;
}
</pre>
      </tab>
    </tabset><h4 id="authentication-manager">Authentication manager</h4>
<p>APIs sometimes need to autenticate to access some data. If not, a 401 &#39;unauthorized&#39; response is thrown.</p>
<p>This is a really simple authentification management in our <code>api.coffee</code> server:</p>

    <hljs language="coffeescript" include="&quot;code/server/api-6.coffee.pre&quot;"></hljs><p>And a simple module using <code>$http</code> to provide log in and log out buttons:</p>

    <tabset>
      <tab heading="authentication/authentication.coffee">
        <hljs language="coffeescript" include="&quot;code/app/authentication/authentication.coffee.pre&quot;"></hljs>
      </tab>
      <tab heading="authentication/authentication.jade">
        <pre>h1 Authentication

.row
  button.login(ng-click='login()')
    i.icon.icon-sign-in
    |  Log in
    
  button.logout(ng-click='logout()')
    i.icon.icon-sign-out
    |  Log out
    
.messages
  .message(ng-repeat='message in messages')
    {{message}}
    </pre>
      </tab>
      <tab heading="authentication/authentication.less">
        <pre>.login, .logout {
  .btn;
  .btn-lg;
  .make-xs-column(3);
}

.login {
  .btn-success;
  .make-xs-column-offset(1);
}

.logout {
  .btn-danger;
  .make-xs-column-offset(4);
}

.messages {
  .row;
  margin-top: @padding-base-vertical;
  .message {
    .alert;
    .alert-info;
  }
}
</pre>
      </tab>
      <tab heading="app.coffee">
        <hljs language="coffeescript" include="&quot;code/app/app-6.coffee.pre&quot;"></hljs>
      </tab>
      <tab heading="app.less">
        <pre>[...]
@import "authentication/authentication";
</pre>
      </tab>
    </tabset><p>We can finally empowered our <code>errorsInterceptor</code> to redirect to authentication page when we&#39;re not logged in:</p>

    <hljs language="coffeescript" include="&quot;code/app/app-7.coffee.pre&quot;"></hljs>
  </li>
</ol>
<div class="conclusion">
  <p>
    We now have a synthetic boilerplate to start an Angular app that handles perfectly API communication.
    We can still imaginate a lot of useful features to start with:
  </p>
  <ul>
    <li>animations:<small> use ngAnimate for alerts, route change,...</small></li>
    <li>details:<small> use ngCloak to prevent unwanted display of errors before compilation</small></li>
    <li>modularization:<small> separate components like the errors interceptor and the loading interceptor into modules</small></li>
  </ul><p>Don&#39;t hesitate to collaborate on the <a href="https://github.com/davinov/kewl">GitHub repository</a>!</p>

</div>