
<h1 class="text-center">Kewl brunch skeleton walkthrough</h1>
<p class="lead">
  Angular apps are client-side apps, often single-page.
  They land their code on the client, then load on demand data from the server using AJAX.
  Unlike regular web pages (without AJAX) where all the content is generated by the server, when the content changes,
  useful indicators provided by the browser are not triggered (loading bar, error messages,...).
  Moreover, nothing indicates to the user something is happening, preventing him to diagnose an eventual error.
  Angular provides all the tools we need to address this lacks.
  Let's walk together though this boilerplate code to start an Angular app capable of communicating elegantly with APIs.
  
</p>
<ol>
  <li>
    <h2>Starting a new brunch project<small> The beginning of all good story</small></h2><p>To start a client-only app easily, I suggest using tools like <a href="http://brunch.io">Brunch</a>,
<a href="http://yeoman.io/">Yeoman</a> or <a href="http://lauterry.github.io/ngTailor/">ngTailor</a>.</p>
<p>Let&#39;s use Brunch and generate a project based on the <a href="http://vbrajon.fr">@vbrajon</a>&#39;s
<a href="https://github.com/vbrajon/brunch-skeleton">brunch skeleton</a>:</p>
<pre><code>brunch new gh:vbrajon/brunch-skeleton kewl-app
cd kewl-app
brunch watch --server
</code></pre><p>And watch your app live on <a href="http://localhost:3333">http://localhost:3333</a> !</p>

    <div class="tip"><p>You can publish you client-side app really easily on Github pages by inititing a repo in your <code>public</code> folder,
switching to gh-pages branch, commiting all files there and pushing to your repo on Github.
See the README file for more info.</p>

    </div>
  </li>
  <li>
    <h2>Creating our backend with Express<small> Love at the first sight</small></h2><p>Let&#39;s create some backend for our brand new Angular app.
Having a REST API as a backend is a great choice, as it&#39;s allow other developers to create easily new fontends to
use the data it exposes (native mobile apps, desktop apps,...) and interacts with others services.
The easy syntax of <a href="http://expressjs.com/">Express.js</a> will help us creating one easily.</p>
<h3 id="serving-our-front-end-with-express">Serving our front-end with Express</h3>
<p>As Brunch&#39;s basic server do, we need to send the user our static files (the Angular frontend).
After Express&#39;s install with <code>npm install express --save</code>, we create a new <code>server/api.coffee</code> file containing :</p>
<pre><code>express = require &#39;express&#39;
path = require &#39;path&#39;

# Configuration
api = express()
api.set &#39;title&#39;, &#39;Kewl&#39;

# Frontend static files
api.use express.static path.join __dirname, &#39;../public&#39;
api.get &#39;/&#39;, (req, res) -&gt;
  res.sendfile &#39;index.html&#39;,
  root: path.join __dirname, &#39;../_client&#39;

# API routes
# Will come later!

# Functions to start and stop the server
api.start = (port = 3333, path, callback) -&gt;
  api.listen port, callback
  console.log &#39;Server listening at port &#39; + port
api.stop = (callback) -&gt;
  api.close callback

# Starting our server
api.start()
</code></pre><p>We can than start our server with <code>./node_modules/.bin/coffee server/api.coffee</code>.</p>

    <div class="tip"><p>By installing globally CoffeeScript (<code>npm install -g coffeescript</code>), you can use only <code>coffee server/api.coffee</code>.</p>

    </div><h4 id="integrating-express-with-brunch">Integrating Express with Brunch</h4>
<p>As Brunch provide us an easy development server, we might want to continue using our <code>brunch watch --server</code> to
be the only requirement to start the app.
In Brunch config file <code>config.coffee</code>:</p>
<pre><code>exports.config =
  server:
    path: &#39;server/server.coffee&#39;
</code></pre><p>And in <code>server/server.coffee</code> :</p>
<pre><code># Called by brunch --server
api = require &#39;./api&#39;
module.exports =
  startServer: api.start
  stopServer: api.stop
</code></pre><p>Now, <code>brunch watch --server</code> starts our Express serving our frontend, so the line <code>api.start()</code> is no longer
desired in <code>server/api.coffee</code>.</p>
<h3 id="some-basic-routes">Some basic routes</h3>
<p>In this example, we&#39;ll create the most basic REST API of the world: one that handles a list of To Dos.</p>

    <div class="note"><p>In a nutshell REST services are built around fours verbs:</p>
<ul>
<li><code>GET</code> to aquire data</li>
<li><code>POST</code> to add data</li>
<li><code>PUT</code> to update data</li>
<li><code>DELETE</code> to remove data</li>
</ul>
<p>E.g., to acquire this webpage&#39;s content, your browser is doing a <code>GET</code> request to the server that respond
with the code of the webpage. Same for the pictures, the fonts...
When you&#39;re submitting a form, it&#39;s generally a <code>POST</code> request.</p>
<p>Request are addressed to an URL and can contain some extra data:</p>
<pre><code>POST http://my-awesome-website.com/newsletter/subscription
{
  email: &#39;give-me-spam@me.com&#39;
}
</code></pre>
    </div><p>Let&#39;s implement a very easy example: a ToDo list.
Consider an array of ToDos like this:</p>
<pre><code>[
    id: 0
    title: &#39;Buy chocolates&#39;
    details: &#39;Prefer the ones without liquor&#39;
    done: false
,
    id: 1
    title: &#39;Buy flowers&#39;
    details: &#39;She prefers yellow ones&#39;
    done: false
,
    id: 2
    title: &#39;Write a note&#39;
    details: &#39;To be put in the flowers&#39;
    done: true
]
</code></pre><p>We need the following routes:</p>
<ul>
<li><code>GET /todo</code> will send the list</li>
<li><code>POST /todo</code> will add an item</li>
<li><code>DELETE /todo/:id</code> will mark an id as done</li>
</ul>
<p>Express makes easy to create this routes easily:</p>
<pre><code>_ = require &quot;lodash&quot; # Needed for _.find method

# Configuration
api.use express.bodyParser() # Populates req.body

# To do storage
id = 2
toDoList = []

# API routes
api.get &#39;/todo&#39;, (req, res, next) -&gt;
  res.send toDoList

api.post &#39;/todo&#39;, (req, res, next) -&gt;
  newToDo = req.body
  newToDo.done = false
  id = id+1
  newToDo.id = id
  toDoList.push newToDo
  res.send newToDo

api.del &#39;/todo/:id&#39;, (req, res, next) -&gt;
  toDoItem = _.find toDoList, id: parseInt(req.params.id)
  toDoItem.done = true
  res.send toDoItem
</code></pre>
    <div class="tip"><p>API are testable without any frontend with tools like <a href="http://getpostman.com">POSTMAN</a>.</p>

    </div><h3 id="angular-way-of-interacting-with-the-api">Angular way of interacting with the API</h3>
<p>As interaction between a REST API is a common pattern in Angular apps, a module called
<a href="http://docs.angularjs.org/api/ngResource">ngResource</a> provides us a useful <code>$resource</code> service to map objects
described in the API.</p>
<p>To install ngResource module:</p>
<pre><code>bower install angular-resource
cd vendor
ln -s ../bower_components/angular-resource/angular-resource.js 17-angular-resource.js
</code></pre>
    <div class="note"><p>Brunch normally uses the <code>main</code> attribute from <code>.bower.json</code> to detect the file he needs to include in vendors
(it&#39;s the strategy used by the <a href="https://github.com/scotch/angular-brunch-seed">angular-brunch-seed</a>.
Symlinking the files we want to include seems better to me though as we can inlude other files, control their
order (also possible with <code>before</code> and <code>after</code> attributes in brunch&#39;s <code>config.coffee</code>) and avoid Brunch&#39;s warning when
a <code>.bower.json</code> is missing (which is often the case).</p>

    </div><p>Let&#39;s create a new module <code>kewl.todo</code> in our app in a <code>toDo</code> folder (<a href="http://www.johnpapa.net/angular-growth-structure/">modularized folder
structure</a>):</p>

    <tabset>
      <tab heading="todo/todo.coffee">
        <pre>todo = angular.module 'kewl.todo', ['ng', 'ngRoute', 'ui.bootstrap', 'ngResource']

todo.config [
  '$routeProvider'
  ($routeProvider) ->
    $routeProvider
    .when '/todo', templateUrl: 'todo/todo.html', controller: 'toDoController'
      ]
      todo.controller 'toDoController', [
  '$scope', 'ToDoList'
  ($scope, ToDoList) ->
  $scope.toDoList = ToDoList.query()
]

todo.factory 'ToDoList', [
    '$resource'
    ($resource) ->
      $resource 'todo/:id'
]</pre>
      </tab>
      <tab heading="todo/todo.jade">
        <pre>h1 To do list

accordion
accordion-group.to-do(ng-repeat='toDo in toDoList', ng-class='{done: toDo.done}')
  accordion-heading {{toDo.title}}
  {{toDo.details}}</pre>
      </tab>
      <tab heading="todo/todo.less">
        <pre>.to-do {
  &.done {
    .text-muted;
    .panel-heading {
      .text-muted;
      text-decoration: line-through;
    }
  }
}
</pre>
      </tab>
    </tabset><p>That handles display of tasks. We still need to create the front-end for POST/DELETE requests:</p>

    <tabset>
      <tab heading="todo/todo.coffee">
        <pre>todo.controller 'toDoController', [
  '$scope', 'ToDoList'
  ($scope, ToDoList) ->
    $scope.refreshToDoList = ->
      ToDoList.query()
      
    $scope.sendButtonDisabled = false
    $scope.newToDo =
      title: ""
      details: ""
      
    $scope.addNewToDo = ->
      $scope.sendButtonDisabled = true
      ToDoList.save $scope.newToDo, ->
        $scope.newToDo =
          title: ""
          details: ""
      $scope.sendButtonDisabled = false
      $scope.refreshToDoList()
      
    $scope.markAsDone = (toDoItem) ->
      ToDoList.delete
        id: toDoItem.id
      , ->
        $scope.refreshToDoList()
        
    $scope.refreshToDoList() # Load the to-do list for the first time
  ]</pre>
      </tab>
      <tab heading="todo/todo.jade">
        <pre>h1 To do list

accordion
  accordion-group.to-do(ng-repeat='toDo in toDoList', ng-class='{done: toDo.done}')
    accordion-heading {{toDo.title}}
      button.mark-as-done(ng-click='markAsDone(toDo)')
        i.icon.icon-check
    {{toDo.details}}
  accordion-group.to-do.new
    accordion-heading
      .row
        input.title(type='text', placeholder='Add a new task...', ng-model='newToDo.title')
        button.send(ng-click='addNewToDo()', ng-disabled='sendButtonDisabled')
          i.icon.icon-plus
          |  Send
    textarea(placeholder='More details?', ng-model='newToDo.details')
    </pre>
      </tab>
      <tab heading="todo/todo.less">
        <pre>.to-do {
  .mark-as-done {
    .btn;
    .btn-success;
    .pull-right;
    padding: @padding-xs-vertical/2 @padding-xs-horizontal;
  }
  
  &.done {
    .text-muted;
    .panel-heading {
      .text-muted;
      text-decoration: line-through;
    }
  }
  
  &.new {
    .title {
      .form-control;
      .make-xs-column(8);
      .make-sm-column(10);
    }
  .send {
      .btn;
      .btn-primary;
      .make-xs-column(4);
      .make-sm-column(1);
      .make-sm-column-offset(1);
  }
  textarea {
      .form-control;
  }
  }
}

</pre>
      </tab>
    </tabset>
  </li>
</ol>